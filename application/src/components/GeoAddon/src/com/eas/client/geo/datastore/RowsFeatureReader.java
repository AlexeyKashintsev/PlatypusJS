/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package com.eas.client.geo.datastore;

import com.bearsoft.rowset.Row;
import java.io.IOException;
import java.util.List;
import java.util.NoSuchElementException;
import java.util.logging.Level;
import java.util.logging.Logger;
import org.geotools.data.FeatureReader;
import org.geotools.feature.simple.SimpleFeatureBuilder;
import org.opengis.feature.simple.SimpleFeature;
import org.opengis.feature.simple.SimpleFeatureType;

/**
 *
 * @author pk creation, mg refactoring
 */
public class RowsFeatureReader implements FeatureReader<SimpleFeatureType, SimpleFeature> {

    private final SimpleFeatureType featureType;
    private boolean closed;
    private final List<Row> rows;
    private int fieldsCount;
    protected int[] pkFieldsIdxes;
    private int rowIndex;
    private SimpleFeatureBuilder featureBuilder;

    public RowsFeatureReader(List<Row> aRows, int[] aPkFieldsIdxes, int aFieldsCount, SimpleFeatureType aFeatureType) throws Exception {
        featureType = aFeatureType;
        rows = aRows;
        pkFieldsIdxes = aPkFieldsIdxes;
        fieldsCount = aFieldsCount;
        rowIndex = 0;
        featureBuilder = new SimpleFeatureBuilder(featureType);
    }

    public SimpleFeatureType getFeatureType() {
        return featureType;
    }

    public SimpleFeature next() throws IOException {
        try {
            if (closed) {
                throw new IOException("Reader is closed!");
            }
            if (hasNext()) {
                SimpleFeature feature = buildFeatureFromCurrentRecord();
                rowIndex++;
                return feature;
            } else {
                throw new NoSuchElementException();
            }
        } catch (Exception ex) {
            throw new IOException(ex);
        }
    }

    public boolean hasNext() throws IOException {
        if (closed) {
            throw new IOException("Reader is closed!");
        }
        return rowIndex < rows.size();
    }

    public void close() throws IOException {
        closed = true;
    }

    private SimpleFeature buildFeatureFromCurrentRecord() throws Exception {
        Object[] rowValues = rows.get(rowIndex).getCurrentValues();
        for (int i = 1; i <= fieldsCount; i++) {
            featureBuilder.set(i - 1, rowValues[i - 1]);
        }
        featureBuilder.set(fieldsCount, rows.get(rowIndex));
        return featureBuilder.buildFeature(generateFeatureId(rowValues));
    }

    private String generateFeatureId(Object[] aRowValues) throws Exception {
        if (pkFieldsIdxes.length == 0) {
            // Feature ID can be generated by geotools automatically.
            Logger.getLogger(RowsFeatureReader.class.getName()).log(Level.FINE,
                    String.format("Could not find key columns in rowset, relying on Geotools capability of IDs generation. Note, that in such case features' IDs will not match records' IDs.")); //NOI18N
            return null;
        } else {
            final StringBuilder sb = new StringBuilder();
            String delimiter = "";
            for (int pkIdx : pkFieldsIdxes) {
                sb.append(delimiter).append(aRowValues[pkIdx - 1]);
                delimiter = ",";
            }
            return sb.toString();
        }
        /*
        ArrayList<Field> pks = fields.getPrimaryKeys();
        if (pks == null || pks.isEmpty()) {
        // Feature ID can be generated by geotools automatically.
        Logger.getLogger(RowsFeatureReader.class.getName()).log(Level.FINE,
        String.format("Could not find key columns in rowset, relying on Geotools capability of IDs generation. Note, that in such case features' IDs will not match records' IDs.")); //NOI18N
        return null;
        } else if (pks.size() == 1) {
        return String.valueOf(rows.get(rowIndex - 1).getColumnObject(fields.find(pks.get(0).getName())));
        } else {
        final StringBuilder sb = new StringBuilder();
        String delimiter = "";
        for (Field pk : pks) {
        sb.append(delimiter).append(rows.get(rowIndex - 1).getColumnObject(fields.find(pk.getName())));
        delimiter = ",";
        }
        return sb.toString();
        }
         */
    }
}
